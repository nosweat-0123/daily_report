- `session`メソッドを使って、ユーバーIDを保存するのは、ブラウザを閉じると消えてしまう。→セッションの永続化として、記憶トークンを生成し、`cookies`メソッドによる永続的cookiesの作成や、安全性の高い記憶ダイジェストによるトークン認証に記憶トークンを活用する。
- 手順としては、
- １、ランダムな文字列を生成して、それをコクトークンとして使う。
- 記憶トークンは、ハッシュかしてデータベースに保存する。
- 記憶トークンをブラウザのcookiesに保存するときは、有効期限を設定する。
- 記憶トークンをブラウザのcookiesに保存するときは、ユーザーIDを暗号化する。
- 以降、もしブラウザのcookiesに暗号化されたユーバーIDがあったら、複合したユーザーIDでデータベースを検索して、データベースのハッシュないのハッシュ値と一致するか確認する。
- `remember_digest`属性をUserモデルに追加する。
- ユーザーIDをそのまま`cookies[:user_id] = user.id `としてcookieに保存すると、悪意のあるユーザーに利用されてしまうかもしれないので、`cookies.encrypted[:user_id] = user.id `として、IDを暗号化してからcookienに保存する。
- 暗号化されたトークンとがユーザーの記憶ダイジェストと一致することを確認する`BCrypt::Password.new(password_digest) == unencrypted_password`は、`==`演算子が再定義されており、`is_password?`という論理値メソッドになっている。
  →authenticated?メソッドを定義して、渡されたトークンがダイジェストと一致したらtrueを返すようにする。
  永続的セッションの場合は、session[;user_id]が存在すれば、ユーザーを取り出し、それ以外の場合は、`cookies[:user_id]からユーザーを取り出して対応する永続的セッションにログインする必要がある。
  現在のユーザーは、current_userヘルパーに定義する。
  ユーザーがログアウトできるようにするためには、ユーザーを記憶するためのメソッドと同様の方法で、ユーザーを忘れるためのメソッドを定義する。`user.forget`メソッドを呼んでから、user_idとremember_tokenのcookiesを削除する。
  バグを防ぐために、ユーザーがログインしているときのみ、ログタウトさせる必要がある。
  
